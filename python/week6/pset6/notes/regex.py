# coding=utf8
# the above tag defines encoding for this document and is for Python 2.x compatibility

import re


regex = r"AGATC"

test_str = "AATCCTGGTTGGACATACCGTTTTCCACACAAATGCCCCAGACACTGTACGGAGACCCTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTCTAGTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTTTTTTTCTAAGAACCGGGGTTTTGGCTGATTCACCGAGTCAACCTAAGACACTAGTTAAACATGTTTGTCGATTATATCACCTTTCATATATTCCGAGCGACACTTTTCAATGCTATATGGTGCTTATTCCTGCTTACCATTTTCGGACCCAGGCCTCAACTTTTGCTTGTACGACATGAAAGGTGCAGCTCTACTTGGATAAGGTGTACTACCTAGCTTACTCGCACCGGACCATTAGCTATTACAGGGTTTGGATAGTTACGTGATGATCGAGGCAGACACCGTAAGACTCTTACGCGCCCGACGGTCCCCGTTAATGATGACAGTGACGAAAGGATTGAGAGGCGCGTCAGACCCCTGTTCCCATATTGTATGTTGTCGTTGGTACGGGCGCCTTACGGAGTAAGGTGTTAGGCAGGAATGGCCAAAGGTTGGTGAACCTGAATCATGGTTGACACGCAGCTCTCTACATTTATGGGCGTATTCCTATTCGCGACTACTACAACTCTTCGGCCGCCGGTAACCGTACGGTGGCTAGATGCCGCTCATACAAAGTATGCGAGCCGTATTCAGAGTATAATGACCTGAAGGAGTACATGAGGGTCATGGTCCGCAGGGACTCCCTGTCATATGCTGAGATGGAGCCATAATCCCTGCCAGCCGTGTGGACTCAGGCATTCCTGTATTAAGCACTCTAGCCCTCGTGAATGCTTGGAAGAGTCACCCAAGGAATCGATTATCACAGGTTGGGAGAGGATGTTTTTCAAGGCCCTGAAAATTTGAAGGGGCTATTGACTGCGGCGTTACAACCAAAGAGATGACGGAACCATTGCTTCCGTCATGCTGGTGTCCCTGTGCGACCCACCGTGTTTGCTCCAATAAGTGGAAGGGTAAATTGATTACTACCGGTTTCATAGGAAGTTCGAGGTGCACGGTTGAGTAGCATTAGAGCTTCGAGCCAGGTTACCATAGTTATCTTTATGGGGCACTCGCCCTGATGTTTACGCCAGGGTTTAGCTTTGTGATCCGTTAGGGGGTTACCTACGACGCAGCAATTAGCGGGTGTCGCAGGTGTGTAGTTTGTGGCACCAAGCCAGCGGGCTTTACTTAACCAACCCTGGGAAGATCACTTCATCCGAATATGAGATCGCCCAACGCTAATACGCCGAAATGGGAACTGAAGGTCTTAGACTAGCTCACGAACCGTATACCTTAAGTTCCCTAAGCGGACGAATTTTTACTAAGTAAGGATTGCAGGAATATGGAAATCATCCGTACGTGCTTTGACGACCCAAAAAGAGGATCAATGGTATCTACCCAAAGCGTTATTCCTAGTACCAGGAGCCTAAATCATTTATAAAAAAATGCAACCTTTACCGTGGAGCGAAGGAAACTCTACTTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTATCTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGTCTGGTGTCAACCGTAGCCTGGTAGATGGAGGATGGTCGACTGGCTCAGATCCACCCTTGTGGCGGCATAACAAAATGTTCACTGAATTGGGCGAAAAATTAGCGAGTGTCACTTGACAAGGACTGAATAGCAGCAACAACCGTCGAGATCGTTGTCCAGTCACGCGGACTGATGATCTTAGATATAACGCAGAACTCAATGGCTCCTCCTGTACTATGATAGGGCGATATAGCGAGCCGAAAACTCGGGCCGGATGAGCGCTCACTGCGGTCCCGCAGCGCTGTTACGACGCCACGTTACCCTTGATCCGTGGTTGGTAGTGTCGCGTGATGAATGCACGAGTTGGTACCGTTCTAAGATCGACTACACGTGGCTCGATTTTAGCAAGTGTGCGATACCTGAATAGTCTGTAACAGTCCGGCGACCCATGGAAGCCGTTTCGTCCCGTATGCCAAGGCCCCGTTTATCCCTCAGCATGGGAATGACGGCCACCAGTGGTCCGTGTTCGCGATCAGTCTCGGGGAGGTACACACCCTCACTGTAAACTGGCAAGGAGGTGATTTTGCCCAATCTGAGAGCCTAAAGTGGCAGTACAGGTTCCTCACACATAACGAGGTACTTGCCTAACTACGTCCTATGTAGACAGGATAAGAAAACGCAGAGCGCGACCGCCGTGCAGTAATGAGTACTAAGGTAACTGGCCGCTCATATGTTCAGTACTGTCACCGTGTTGGTTAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAAGAAATCGACGCTAAGTCGGCTTCAGACTCTTGCGATGATTCCGATTCGGCCTTTTCCCTCAGTGCTTCTCAGCAGGCAACTTGCGAAAAGCATATCGCGCATTAGTACAACAGCAATTACTACACGACCAAAACGTCGTGGAGAGTCGCTGTACTGCAGCTCAAGGGTGGCCGACCATAGAACATTTAACGATATGCACGATCCGGTCAAATATCACAACAGAATTGTGTGCTAGTAGGGGAAAAGGGGAAGGCCCTTCCTTGGGATAGATAGATAGATAGATAGATAGATAGATAGATAGATAGATAGATAACCGACTCATTGCGGAATTTTCAGTTTTACAATGCGGTGACCACTAGCCAACGGCGTCATTGATAATGATACTAACTTCCTTGGGGCGACTCCGGTTTAAAAGTGGCCGGTACGCTTGTTCGACATCATGTGTAGCGTTATTAGGACTGAATTACCGGGCCCCGTTCCGAGATGTTCTTTTTCGGCCCCTGGCGCAGAGGCGCTTGAGCTGCATATACTGGAATATAAGAGGTCACTCGCGAGAACGGTCACGCTACCATGTCGGCAGGATGCAGGATCAGGAATAATGTGGTAGACCTGTGTTCAACGGTGATCTCGGTGTGGATCGGGTGAGCACCAGATCGACTAACTAAGGGATATGCAAGCAGATTCTTCGGACGCCTTTGCCGGTAACACATGGAACACGCCTATGCGCTCCATTACTGGGTGCCTTGTTGAGACGGATAGGTCGGGTTCAATGATTATTAAGGTTTATCAACGTATTACTGCTTGTAACGGCTTGTAAGTGCCAATTGTCATTCGACCCCGGCTGGTCTGACAAGGTTTGTACGCCGATTTGGCATGAGGGGACTAGAGTGGAATAGGATTGTGCACTAAGCTGCGGTCCCGCCTGCGTACCCGCGTATCAAGTGGCTCGGTGGCTGGTTGCGATTACTGAGCTCGTGCATTGCTATCAGTGCGTCCCCTGCAAGAACAGGTATCAAGTGTGGTTCCGTATTGCACGATTGACAATTTCATCGGGTATTCGCTCGTCGGCAAACATTGAAGGCTTCATAGGTTCACAACCGCGTTCCCTGTGATGCGGAATCGCGAGATCTGGATCATCCTTCTAAGACACTCAAAATGCAGACGTCGAGAGACGTATGCGTCCGCGGGAACTATGGCATCTGCCCTTAACATGTGAAGAGACTGCTTTAGCTCGATCTAACCGTAGGCCCTTCATGAAGAGAAGCCATTGTCGGGGGTAGTGACTTTTGGCCGTACGTGATTAAATAACACGGAGTCAAACTCGGAGCGTTCCGTCTCTGATATCGCCAACATCGCAAGCTCCCTACGTACCACCCTGGGTGAACACGACTTTAATGCTTTGAAAATATTGATGGAGACGGCACAAATTTCCGAAAACTCGAAACTTAGTAAATTTACACTGAAAAACCCGGGCGGACAAGTACAAGAGTCCGCGCTCGTAGTGCTCTGTTGAAGCGTTGACCTCTGTCGCTTAAAATCGTAAAGACTTTATACACGAATATTGAGTGAGAAAGAGTCCCCGATCTATCATTACAAATATTCCGTTCTACAATCTGAGGCCAGACAGTTTTGTTCCCTCTCCTTACCTAGTGCCATATCGAGGGACAGAAATTTGACACCTTGCAGTCACACGTTGTTTTGAGATATGCAAACCACGCCCAGTGTCGAGATCCCACATATCTTCATTATAAGCTCGACCACTTGAGACTGCAGCACGAAGGCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGATCAGAAATTCCAAGCAATGGCTTCAGCGCTCGGACGCCCCGCCCGTGCCCGGCGTGAACATATGGATGTATGAATTATTGCATGGTCTGTATCTTAATGCGCGCTTGGCAACACATGTGAGAACGGTCTCACGTGCGACTACGTATGATCTATGCAAATGTGCGGTGGCGCCCGGCCTTTTTAGGAGGTTCCTAGACCAGGAGCCTGTGTGGTAAGGGCCGGCAGACGTTTCCGGTACGCTCCGCCAAGAAGGTAACCATGCGGCCCGGTAATGTAACCAGGTCTCGAAAAAATTAGGCGAATCGAAAGGGTTCTATCGGACCGTTAACAATTTACGGTCATTCTAGTATGCATTCAAGGAACCGACTCTCGTCTCACATTTATGTCATCATTATGACTAACGCAAGCTGTTACAACGTGACTACTCACCTGGATCGTCATCACGCGCGATGTGCATGAACTCGCAAAAACGAACCTAATCGAACGGTTATCGGTGACATTTGATTTTGAGTCTGCGGCACGTAAAAGCTCTGGGATGCAGCTCCTATATCAGCCTAGGGGTCGGGCTCTCTGGTTCTGCTCGCTAGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGAATGCAGTCCCGTGAGTGAGTAGTATACGCGATCTTGTGTGTCTAAGTTATTGCCACACACGAATGACCAAATACGAGATCTAGACTCGTGTATATGAGACAGGTTGCACAATCAGCCTTTATTCTGAGACAGTGGTGCTGGGGATGGCTTGAGATACATACGCACACAAGCCCAGGGGGATTAATTGCTGCGCAGATAGCCCGCCCAAAGTTGTCCCAGTGACCTTAGAAGGACCCTGTACCTGGCGTTGGGTAAGACACGTCACCCGTCGTAGCCGTGTATAGCCGAGCGTCCTGCAAAAGCGTATCTTTTTGATGAGCGAAATCGCGTCCAAAGACTTCGCTCAATTCAGAAGGCTCGAATTGCCGATCGTCGCAGGGCTGCATTAGGCACGCCAGTTCTTCTAGGTCCCGGGCCGAGAGTGTTCGGCGGTAACTGCCTTTTAGGGGCCGCACACCTCGGCTGCGGCCGGGCGGAAGGCGCTTACTTCTGGATGCGGCTTCAGACGGCTGTAATATGTCTCGGAATACCGCTCAGCATACGAGGAGTCTCCGCTTTCGACAGCCTGGGGCCACGTCGTGTTGAA"

matches = re.finditer(regex, test_str, re.MULTILINE)

for matchNum, match in enumerate(matches, start=1):

    print("Match {matchNum} was found at {start}-{end}: {match}".format(
        matchNum=matchNum, start=match.start(), end=match.end(), match=match.group()))

    for groupNum in range(0, len(match.groups())):
        groupNum = groupNum + 1

        print("Group {groupNum} found at {start}-{end}: {group}".format(groupNum=groupNum,
              start=match.start(groupNum), end=match.end(groupNum), group=match.group(groupNum)))

    # what if I log the indexes they were fo


def getHighestOccurances(itemToSearchFor, dnaInQuestion):

    # Location to store my results
    indexLocations = []

    # sub function to check the string for every instance it exists
    def checkSubString(startingIndex, itemToSearchFor, dnaInQuestion):
        result = dnaInQuestion.find(
            itemToSearchFor, startingIndex, len(dnaInQuestion))
        if (result == -1):
            return

        else:
            indexLocations.append(result)
            checkSubString(result + (len(itemToSearchFor) - 1),
                           itemToSearchFor, dnaInQuestion)

    checkSubString(0, itemToSearchFor, dnaInQuestion)

    # now I have an array of numbers I can check - loop over the thing and compare the number to the next in the sequence
    # if it is = next number - len(itemToSearchFor), add it to a tally.
    # if not, start a new tally and continue the check

    def countOccurrances(arrayOfOccurances):

    print(indexLocations)
